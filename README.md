# shortenurl-v2

# 开发用:
1. 流程解释:
存在api-gateway
存在三个微服务,链接处理微服务,租户处理微服务,数据分析微服务

api-gateway接受http请求，然后根据请求类型，使用grpc调用三个下游服务

链接处理下游服务负责生成短链接或还原短链接。它会与redis和数据库交互，将结果发回给api-gateway，并往消息队列里记录这次点击事件

租户处理下游服务负责处理租户添加和租户查询,租户修改

数据分析下游服务负责数据采集和数据查询。它会监听消息队列以采集数据，并将数据写入数据库(如点击量等等)。它也会与redis和数据库交互，提供数据查询功能

---

## 链接处理

链接处理服务会有大量读请求(还原链接请求),而且读写比十分悬殊

需要做好缓存服务

### 性能

多级缓存

### 安全性

缓存穿透:
缓存雪崩:
缓存击穿:

### 整个流程

生成短链接是根据原链接生成短链接
TODO: 批量生成
**算法(暂定):**
>不允许过期链接复用,该删就删
1. 生成字符串,格式:"租户id:长链接"
2. 用murmurhash哈希算法进行哈希,并用base62算法进行转换得到短链接
3. 若该租户下已有该短链接,则重新生成字符串,格式:"租户id:长连接:随机字符串(8)",然后重复过程

还原链接是从数据库或者缓存里拿

生成短链接时需要往消息队列发消息,保证数据分析的库的维度表里有链接的信息.这样链接过期删除之后还能保有相关信息,而且在同一个数据库里.
还原短链接时需要发点击记录消息,供数据分析服务进行分析和记录.
> CDC暂时使用rabbitmq,日后再改成kafka,或者用更加正统的CDC

## 数据分析服务

> 暂时使用mysql,日后应该改成OLAP数据库,例如click house

定期从创建链接队列**拉取**消息,并写入维度表.
拉取是为了性能

点击事件的获取采取**推送**方式,分析数据,并将相关内容写入事实表里
> 暂且不分析,直接写入user-agent

查询则是从redis或者数据库拿

对于点击量这样的数据,只放在redis里.通过后台协程将用不到的写到数据库里?ClickHouse好像很擅长这种东西
或者定期写入数据库?但是可能丢失
批量ack?

### 幂等性

链接处理服务给点击事件加上唯一标识码(uuidv7)

通过redis和唯一键(?可能拖累性能)来实现幂等性

## api-gateway

速率限制
请求校验

## 可观测性

