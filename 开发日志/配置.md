我采用的是分层配置, 通过 Viper 实现 公共配置 + 服务专属配置 + 环境变量 三者实现整合
目标是：
- 避免重复定义配置结构体
- 不同服务共享一套基础配置
- 服务可按需覆盖或扩展配置
- 环境变量拥有最高优先级，适用于容器化部署

# 配置文件分层结构
整个配置体系分为两层：

## 公共配置
路径：shared/commonconfig
包含所有服务都可能用到的配置结构体，例如：
- Redis
- RabbitMQ
- MySQL
- Jaeger
- 服务基础信息

这些结构体放在公共模块内，保证所有服务复用同一份定义，避免重复维护

公共配置文件中定义默认值，例如：
```yaml
redis:
  host: 127.0.0.1
  port: 6379
rabbitmq:
  host: 127.0.0.1
  port: 5672
```

## 服务专属配置
每个服务拥有自己的 config.yaml，用于：
- 覆盖公共配置项
- 添加本服务独有的配置字段
例如:
```yaml
prometheus:
  port: 40003
redis:
  pool-size: 50
service-info:
  name: analytics-service
```

# 统一的配置结构体
所有服务的配置结构体都来自公共模块：
```go
type Config struct {
    Prometheus  commonconfig.PrometheusConfig
    Redis       commonconfig.RedisConfig
    RabbitMq    commonconfig.RabbitMqConfig
    ...
}
```
这样每个服务：
- 不需要重复定义 RedisConfig、RabbitMqConfig 等
- 保持结构体一致性
- 配置项的改动只需在一个地方维护

---
对于云原生应用,需要考虑:一份基准代码（Codebase），多份部署（deploy）
真的是太烦人了
配置文件/部署文件也会有配置文件,非常难之管理